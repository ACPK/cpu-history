CPU Mon:
- change app name to CPU History
- change preferences file, all other applicable info.
- test prefs: change in Memory Monitor, see if app picks them up
- remove extraneous information for memory monitor:
	- preferences form
- future upgrades:
	- CPU usage across processors:
		- get # of processors with http://www.cocoadev.com/index.pl?NSProcessInfo
		- add another graph or average across both cores?

	int size = 24, i, j;
	CPUInfo *cpuInfo = [[CPUInfo alloc] initWithCapacity:size];
	CPUData cpuData;
	
	[cpuInfo refresh];
	for (j = 0; j < 48; j++) {
		for (i = 0; i < 1000000; ) {
			i++;
		}
		[cpuInfo refresh];
	}

	[cpuInfo startIterate];
	for (i = 0; [cpuInfo getNext:&cpuData]; i++) {
		NSLog(@"user: %e\n", cpuData.user);
		NSLog(@"sys: %e\n", cpuData.sys);
		NSLog(@"nice: %e\n", cpuData.nice);
		NSLog(@"idle: %e\n", cpuData.idle);
	}
	
	return 0;


key:
- wired = user
- active = sys
- inactive = nice
- free = idle


Archive:
- get it to build @done @project(CPU Mon)
- make another pass through the source to take out extraneous references to CPUUsage @done @project(CPU Mon)
- check TODOs @done @project(CPU Mon)
- how to do data update: make a large float array with my usage data in it, use a rolling pointer to update things. store new data from current cpu stats. @done @project(CPU Mon)
	- is that how the current and last stuff is built? @done @project(CPU Mon)
- in other words, I need to pass the pointer by reference so I can modify its value (ie the memory it points to). keep in mind, someone has to clean up after the old memory. @done @project(CPU Mon)
- memory leak: vm_deallocate the processorInfo array after use: @done @project(CPU Mon)
- methods needed: @done @project(CPU Mon)
	- updateCPUStat: what do we want to accomplish here? @done @project(CPU Mon)
		- get current data @done @project(CPU Mon)
		- retrieve data at last refresh @done @project(CPU Mon)
		- subtract last from current @done @project(CPU Mon)
	- init: init the processor usage data: set the first "lastProcessorInfo" array so update is all good to go. @done @project(CPU Mon)
	- getCurrentData @done @project(CPU Mon)
		- return last data @done @project(CPU Mon)
	- getNext: @done @project(CPU Mon)
		- run update @done @project(CPU Mon)
		- set ptr new data @done @project(CPU Mon)
		- update internal ptrs @done @project(CPU Mon)
	- getPrev @done @project(CPU Mon)
		- return one before last? @done @project(CPU Mon)
- variables needed: @done @project(CPU Mon)
	- CPUData array @done @project(CPU Mon)
	- lastProcessorInfo (for diffs) @done @project(CPU Mon)
	- numLastProcessorInfo (to deallocate it) @done @project(CPU Mon)
	- two variables to track size, location in array @done @project(CPU Mon)
- notes: need TWO refreshes at init to get current info! @done @project(CPU Mon)
 		if(lastProcessorInfo) {
			size_t lastProcessorInfoSize = sizeof(integer_t) * numLastProcessorInfo;
			vm_deallocate(target_task, (vm_address_t)lastProcessorInfo, lastProcessorInfoSize);
		}

		lastProcessorInfo = processorInfo;
		numLastProcessorInfo = numProcessorInfo;
	- first test data coming out of cpu info with logs (this might hurt. limit to one sample every 2 sec) @done @project(CPU Mon)
	- test with xcode debugger to watch array data change. @done @project(CPU Mon)
	- paging rate graph @done @project(CPU Mon)
- switch the source of the graph from memory info to CPU info: @done @project(CPU Mon)
	- then change graphing fct to pull from different data source @done @project(CPU Mon)
	- text overlay @done @project(CPU Mon)
